UIPEthernet library:
 it provides the source code for the UIPUDP class, which is used to handle UDP packets. The UIPUDP class is a powerful tool that can be used to send and receive UDP packets, and it is used by the UIPEthernet library to provide UDP support for Ethernet devices.
 Functions used: 
 1.begin(): It firstly checks if “_uip_udp_conn” is null then it will create a new UDP connection and binds it to a specific port. If the connection is successfully created. Otherwise, will return 0.
2.Stop(): It checks if the pointer is not null, then it remove the UDP connection from the uIP stack, and frees the appdata.packet_in, appdata.packet_next and appdata.packet_out.
3.beginPacket(): used to start a new UDP packet and specify the destination IP address and port. The function first checks if the ip and port parameters are not null and non-zero. If they are, then the function copies the ip address into the ripaddr uIP IP address structure and sets the rport field of the UDP connection object to the port value. If the UDP connection object does not exist, then the function allocates a new UDP connection object and sets the appdata pointer of the UDP connection object to the appdata structure.The function then checks if the appdata.packet_out pointer is NOBLOCK. If it is, then the function allocates a new block of memory for the UDP packet. The size of the block is UIP_UDP_MAXPACKETSIZE plus the size of the Ethernet header and padding. The function then sets the appdata.out_pos variable to the offset of the data area in the packet buffer. If the allocation of the memory block is successful, then the function returns 1. Otherwise, the function returns 0.
4.beginPacket():starts building up a packet to send to the remote host specified in the host and port parameters. The function first checks if the host parameter is not null. If it is, then the function creates a DNSClient object and calls the begin() function to initialize it with the DNS server IP address. The function then calls the getHostByName() function to look up the hostname in the DNS server. The getHostByName() function returns 1 if the hostname was found and 0 if it was not found. If the hostname was found, then the function calls the beginPacket() function to start a new UDP packet with the destination IP address of the hostname and the specified port. If the hostname was not found, then the function returns 0.
5.endPacket(): It sends the current packet. if the uip_len variable is greater than 0, then the function calls the _send() function to send the packet. The function returns 1 if the packet was successfully sent and 0 if it was not.
6.write():This function is used to write a single byte to the current UDP packet that is being built up. It finally returns the number of written bytes.
7.write():This function is used to write a sequence of bytes to the current UDP packet that is being built up. The function then increments the appdata.out_pos variable by the number of bytes that were written. The function then returns the number of bytes that were written.
8.parsePacket():It parses the next UDP packet that is received. The function first calls the tick() function to update the Ethernet state. The function then checks if the appdata.packet_in pointer is not equal to NOBLOCK. If it is, then the function calls the freeBlock() function to free the memory that was allocated for the previous packet. The function then returns the size of the packet.
9.available():It checks whether the UDP packet is available to be received or not.
10.read():Used to read a single byte from the current UDP packet. If it returns a positive value, then the byte that was read is returned, if it returns 0, then there is no more data to read, else if it returns -1, then an error occurred.
11.read():used to read a sequence of bytes from the current UDP packet that is being received.The function first calls the UIPEthernetClass::tick() function to update the Ethernet state.The function then checks if the appdata.packet_in pointer is not equal to NOBLOCK. If it is, then the function calls the readPacket() function to read the bytes from the packet and store them in the buffer array .The function then returns the number of bytes that were read.
12.peek(): It returns the next byte without removing it. If it returned 1, then the byte that was read is returned, if it returned 0 then there is no more data to be read else if it returned -1 then there is an error occurred.
13.flush():It flushes the current UDP packet.
14.remoteIP(): It gets the IP address of the host that sent the current UDP packet.
15.remotePort():It gets the port number of the host that sent the current UDP packet.
16.appcall():This function is called by the uIP stack when there is a UDP packet to be received or sent .The importance of this code is that it allows user-defined code to be executed when a UDP packet is received or sent. This can be used to implement custom logic for handling UDP packets, such as parsing the packet data, storing the packet data, or sending a reply packet.
17.send():This function is used to send a UDP packet. The function checks if the length of the packet is equal to the size of the ARP header. If it is, then the function indicates that the ARP request has been sent. This means that the destination host's MAC address is not yet known, and the uIP stack will need to send an ARP request to the destination host in order to learn its MAC address. If the length of the packet is not equal to the size of the ARP header, then the function indicates that the ARP request has already been sent and the destination host's MAC address is known. In this case, the function simply calls the network_send() function to send the packet.

